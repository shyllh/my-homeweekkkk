## 一、var、const和let区别？
    var声明的变量为全局作用域、而let声明的变量为块级作用域、const声明的常量为块级作用域。
    var声明的变量存在变量提升，而const和let不存在变量的提升。
    var可以重复声明同一个变量、let和const不能声明同一个变量，

## 二、说一说常见的数据类型？
      基本数据类型：String、Number、Boolean、Undefined、Null、Symbol、BigInt

     引用数据类型：object（array、function、date、math、Reg）
## 三、如何判断JS数据类型？
        typeOf：返回判断数据的类型。对于简单数据类型，
        除了null返回object,其他都可以正确判断。对于引用数据类型，
        除了function外都会返回object。
        instanceof：判断对象的原型链__proto__上是否存在构造函数的原型prototype，
        只能判断引用数据类型，不能判断基本数据类型，
         常用来判断a是否为b的实例。
     object.prototype.toString.call()：返回类型为   [object 数据类型]

## 四、解释一下什么是闭包 ?
        闭包：就是能够读取外层函数内部变量的函数。
        闭包需要满足三个条件：
        访问所在作用域；
         函数嵌套；
         在所在作用域外被调用 。

## 五、解释一下原型和原型链 ?
         原型就是一个为对象实例定义了一些公共属性和公共方法的对象模板。
         对象之间的继承关系通过构造函数的prototype指向父类对象，直到指向Object对象为止形成的指向链条。

       通俗讲： 原型链是原型对象创建过程的历史记录。 
## 六、数组排序的方式 ?
    for(var i=0;i<arr.length-1;i++){
            for(var j=0;j<arr.length-i-1;j++){
                if(arr[j]>arr[j+1]){
                    var temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }
        if(arr[j]===arr[j-1]) i++;
        }
## 七、for 循环与 forEach 的区别 ?
          1.for循环可以使用break跳出循环，但forEach不能。
          2.for循环可以控制循环起点（i初始化的数字决定循环的起点），forEach只能默认从索引0开始。
          3.for循环过程中支持修改索引（修改 i），但forEach做不到（底层控制index自增，无法左右它）。

## 八.=== 和==的区别
          ===  三个等号称为同等符。
          当等号两边的值类型相同的时候，直接比较等号两边的值。值相同则返回true。
          若等号两边的值类型不同时直接返回false。
          就是说三个等号，既要判断值也要判断类型是否相等。
          ==：两个等号称为等值符
          当等号两边的值为相同类型时，比较值是否相同，
          类型不同时 会发生类型的自动转换，转换为相同类型后再作比较。
          总的来说就是两个等号 只要值相等 就可以

## 九.怎样理解作用域何作用域链
          作用域：

          变量与函数的可访问范围。 由当前环境与上层环境的一系列变量对象组成。

          作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

        作用域链：

         变量到 创建该变量的函数的作用域中取值。但是如果在当前作用域中没取到。就会向上级作用域中去查，直到全局作用域。

       这样一个查找过程形成的链条就叫做作用域链。

## 十.js中this的五种情况
       普通函数调用，this指向window

       函数作为对象的方法被调用时，this指向该对象。

       构造器调用,this指向返回的这个对象

         箭头函数的this绑定this所在函数定义在哪个对象下就绑定到最近一层对象上
# 5.17
   ## 十一 iframe 是什么？有什么缺点？

               参考回答：
          定义：iframe 元素会创建包含另一个文档的内联框架
         提示：可以将提示文字放在标签之间，来提示某些不支持 iframe 的浏览器
           缺点：
           会阻塞主页面的 onload 事件
           搜索引擎无法解读这种页面，不利于 SEO
         iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。
  ## 十二addEventListener 参数

          参考回答：
       addEventListener(event, function, useCapture)
          其中，event 指定事件名；function 指定要事件触发时执行的函数；useCapture 指定
          事件是否在捕获或冒泡阶段执行。

## 十三， typeof null返回值是多少为什么？


     答：object 因为null指向一个空指针对象


## 十四 简述ajax 流程


      1客户端产生js的事件
      2创建XMLHttpRequest对象
      3对XMLHttpRequest进行配置
      4通过AJAX引擎发送异步请求
      5服务器端接收请求并且处理请求，返回html或者xml内容
      6XML调用一个callback()处理响应回来的内容
      7页面局部刷新。

## 十五，js 导致内存泄漏的情况
     大量使用全局变量
     大量使用闭包()
     清除DOM节点时，只清除节点，而没有删除事件
     定时器不清除


## 十六，使用箭头函数应该注意什么？（箭头函数和function的区别）

     （1）用了箭头函数，this就不是指向window 而是声明时的外部环境
     （2）箭头函数不可以使用arguments（参数的集合）对象
     （3）箭头函数不能使用构造函数，也就是说不能使用new命令，否则会抛出一个错误

## 十七，link 标签和 import 标签的区别
      参考回答：
      link 属于 html 标签，而@import 是 css 提供的
      页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加 载。
      link 是 html 标签，因此没有兼容性，而@import 只有 IE5 以上才能识别。
      link 方式样式的权重高于@import 的。


## 十八，eval 是做什么的
     参考回答：
     它的功能是将对应的字符串解析成 JS 并执行，应该避免使用 JS，因为非常消耗性能
    （2 次，一次解析成 JS，一次执行）


## 十九，null == undefined 为什么
      参考回答：
       要比较相等性之前，不能将 null 和 undefined 转换成其他任何值，但 null == undefined 会返回 true 


## 二十，call 和 apply 是用来做什么？
      参考回答：
        Call 和 apply 的作用是一模一样的，只是传参的形式有区别而已
        1、改变 this 的指向
        2、借用别的对象的方法，
        3、调用函数，因为 apply，call 方法会使函数立即执行
## 5.18
## 二十一，跨域问题是怎样产生的？ 解决方案有哪些？
       同源策略（协议名，域名，端口号（出于安全考虑））
       Jspon 代理 cors
## 二十二，闭包有什么缺陷？
	 答 滥用闭包会造成内存泄漏，因为闭包中引用的的包裹函数中定义的变量永远不会被释放，所以我们在必要的时候及时释放这个闭包函数（赋值为null）
## 二十三， call apply bind方法有什么区别
		答：都可以该表this指向
			Bind 返回值this指向被改变后的函数
			Apply  call 改变this指向并执行函数
			APPly  传递的参数必须是一个数组
			Call    可以一个一个传递参数
## 二十四， es6 箭头函数 this指向和普通函数this指向的区别？     
		答：	 箭头函数 this指向函数声明时的上下文环境       
## 二十五，javascript 的本地对象，内置对象和宿主对象有哪些?
    本地对象为array object regexp等可以new实例化
    内置对象为gload Math等不可以实例化的
    宿主为浏览器自带的documentwindow等
## 二十六，javascript的两种变量范围有什么不同？
      全局变量:当前页面内有效
      局部变量:函数方法内有效
      let 块级 const块级
## 二十七，Promise构造函数是同步执行还是异步执行，那么 then 方法呢？
	答：promise构造函数是同步执行的，then 方法是异步执行的
## 二十八，事件代理在捕获阶段的实际应用
      可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。
## 二十九 暂停死区
     在代码块内，使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”
## 三十 你知道那些事件修饰符
	答：.stop阻止事件冒泡
		.once只执行一次，一次性事件
		.self阻止事件冒泡和事件捕获
		.captrue事件捕获阶段触发
		.prevent阻止浏览器默认行为
		.native 触发原生事件


